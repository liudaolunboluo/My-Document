# 字符串常量池真的在堆上吗？

最近笔者周围有朋友在面试，面试中有个问题是字符串常量池在哪里？特定为jdk8之后，我朋友第一反应是元空间，因为是常量池，这种东西第一反应好像都应该在元空间，但是后来下来一查资料，发现中文资料上都是说的jdk7之后字符串常量池从永久代改到了堆上，这样我朋友就产生了疑问，于是来和笔者讨论，笔者认为这也不怪他，笔者看到常量池第一反应也是元空间，但是幸好笔者看过美团的那篇String.intern的文章，里面清晰的说过字符串常量池在jdk7之后是在堆上：

[深入解析String#intern](https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html)(https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html)

>再说说 jdk7 中的情况。这里要明确一点的是，在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的 Perm 区的，Perm 区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用 intern 是会直接产生`java.lang.OutOfMemoryError: PermGen space`错误的。 所以在 jdk7 的版本中，字符串常量池已经从 Perm 区移到正常的 Java Heap 区域了。为什么要移动，Perm 区域太小是一个主要原因，当然据消息称 jdk8 已经直接取消了 Perm 区域，而新建立了一个元区域。应该是 jdk 开发者认为 Perm 区域已经不适合现在 JAVA 的发展了。

甚至还用了图示来很贴心的解释：

![图示](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/1bdc831a.png)

这里可以看到字符串常量池是在堆上

这里笔者就有点疑问了，如果字符串常量池就在堆上岂不是要参与GC，但是笔者看GC源码之后发现并没有字符串常量池的处理，所以笔者不禁怀疑起来，字符串常量池真的在堆上吗？

ps：本文所有的jvm源码都基于open jdk的hotspot的jdk21版本



## 什么是字符串常量池

首先我们先复习一下这个很经典的java八股：字符串常量池

>JVM 的字符串常量池，是 JVM 为了提高字符串处理效率而创建的一个特殊内存区域:
>
>- **节省内存空间**：当创建字符串常量时，JVM 会首先检查字符串常量池中是否已经存在相同内容的字符串。如果存在，就直接返回常量池中已有的字符串引用，而不会重新创建一个新的字符串对象。例如，定义多个值为 "hello" 的字符串变量，实际上它们都指向字符串常量池中的同一个 "hello" 字符串对象，这样可以避免重复创建相同内容的字符串对象，从而节省内存空间。
>- **提高字符串比较效率**：由于字符串常量在常量池中是唯一的，因此在进行字符串比较时，直接比较字符串的引用是否相等即可，而不需要逐个字符地比较字符串的内容。这种方式可以大大提高字符串比较的效率，特别是在比较大量字符串时效果更为明显。

相信大家在面试中都遇到过这种问题：`String s = new String("abc")这个语句创建了几个对象`

其实这个就是考察字符串常量池的，关于这种八股直接看上文提到的美团上的文章就好了，非常清晰清楚



## 字符串常量池到底在哪里

然后我们接着探寻这个常量池在哪里的问题

首先我们去看一下jvms，找一下里面有没有关于字符串常量池在哪里的规定：

![image-20250408084924003](/Users/zhangyunfan/Library/Application Support/typora-user-images/image-20250408084924003.png)

很遗憾，里面只有对结构的定义

现在我们只能去源码里寻找答案了

利用我们之前的jvm源码知识，看一下jvm初始化的时候有没有这个字符串常量池的相关定义

我们知道jvm初始化的时候会去调用`universe.cpp`中的`universe_init`方法（这个在笔者以前的文章中有提到），所以我们看看这个方法：

```c++
jint universe_init() {
...
 	//初始化堆
  jint status = Universe::initialize_heap();
...
	//初始化tlab
  Universe::initialize_tlab();
	//元空间初始化
  Metaspace::global_initialize();

...

  SymbolTable::create_table();
  //字符串常量池初始化
  StringTable::create_table();

...
}

```

这里我们发现在jvm初始化的时候有一段就是字符串常量池初始化的代码，那我们进去看看：

```c++
void StringTable::create_table() {
  //计算字符串常量池的大小，通过参数-XX:StringTableSize来设置
  size_t start_size_log_2 = ceil_log2(StringTableSize);
  //这里大小是接近但不小于给定值的 2 的幂
  _current_size = ((size_t)1) << start_size_log_2;
  log_trace(stringtable)("Start size: " SIZE_FORMAT " (" SIZE_FORMAT ")",
                         _current_size, start_size_log_2);
  _local_table = new StringTableHash(start_size_log_2, END_SIZE, REHASH_LEN, true);
  _oop_storage = OopStorageSet::create_weak("StringTable Weak", mtSymbol);
  _oop_storage->register_num_dead_callback(&gc_notification);

#if INCLUDE_CDS_JAVA_HEAP
  if (ArchiveHeapLoader::is_in_use()) {
    _shared_strings_array = OopHandle(Universe::vm_global(), HeapShared::get_root(_shared_strings_array_root_index));
  }
#endif
}
```

这里核心就是`  _local_table = new StringTableHash(start_size_log_2, END_SIZE, REHASH_LEN, true);`

而`StringTableHash`的定义是：

```c++
typedef ConcurrentHashTable<StringTableConfig, mtSymbol> StringTableHash;
static StringTableHash* _local_table = nullptr;
```

就是一个`ConcurrentHashTable`，他的底层和java的HashMap差不太多，大家就理解为是一个线程安全的HashMap就行了（其实java也有HashTable）

那这个`_local_table`是不是就是我们的字符串常量池呢？如果是的话，那这个常量池明显是分配在jvm的本地内存中的：

>- **本地内存**：是指JVM在运行时分配和管理的内存，它是为了支持Java程序和Java虚拟机本身的运行而存在的。在JVM中，本地内存用于存放JVM自身的数据结构、线程栈、方法区、堆外内存（Off-Heap Memory）等。
>
>  本地内存是直接由操作系统分配和管理的，不受Java堆内存大小的限制，并且不会受到Java垃圾回收机制的控制。

也就是jvm的C++自己管理分配的内存，这部分内存和堆并没有关系

那么是不是就是说这个字符串常量池就在本地内存里不是在堆上呢？别急，我们在看看intern的源码，可以看看我们的字符串是怎么进入常量池的，以此来验证我们的猜想。

`String`的`intern`是native的，所以我们直接去`String.c`里面看：

```c
Java_java_lang_String_intern(JNIEnv *env, jobject this)
{
    return JVM_InternString(env, this);
}
```

这里调用的是`jvm.cpp`的`JVM_InternString`方法：

```c++
JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
  JvmtiVMObjectAllocEventCollector oam;
  if (str == nullptr) return nullptr;
	//将 JNI 字符串引用解析为 JVM 内部的 oop（Ordinary Object Pointer，普通对象指针）
  oop string = JNIHandles::resolve_non_null(str);
	//将字符串添加到常量池中
  oop result = StringTable::intern(string, CHECK_NULL);
// 这行代码将结果转换回 JNI 字符串引用，并将其作为本地引用返回。本地引用是指只在当前线程有效的引用。
  return (jstring) JNIHandles::make_local(THREAD, result);
JVM_END
```

这里顺便说一下intern方法的返回值问题，这里可以很清晰的看到，intern的返回值就是**该字符串在字符串常量池中的一个引用并且是只在当前线程内有效的本地引用，值就是当前字符串**

所以接下来就是上文中的`StringTable.cpp`了：

```c++
oop StringTable::intern(const char* utf8_string, TRAPS) {
  if (utf8_string == nullptr) return nullptr;
  //资源管理器，用于自动回收在当前线程中分配的资源
  ResourceMark rm(THREAD);
  //计算输入字符串的 Unicode 长度
  int length = UTF8::unicode_length(utf8_string);
  //在资源区域中创建一个新的jchar数组，长度就是传入的字符串长度
  jchar* chars = NEW_RESOURCE_ARRAY(jchar, length);
  //将输入的 UTF-8 字符串转换为 Unicode 字符串
  UTF8::convert_to_unicode(utf8_string, chars, length);
  //创建一个当前字符串的句柄
  Handle string;
  //调用intern
  oop result = intern(string, chars, length, CHECK_NULL);
  return result;
}
```

这里在进入最终的`intern`之前会把我们的字符串转换为unicode字符串然后再去intern（Unicode 是一种字符编码方案，它为世界上所有的字符、符号和表情符号分配了唯一的数字标识符。Unicode 的目标是在各种语言和平台之间提供一种统一、无歧义的编码方式）:

```c++
oop StringTable::intern(Handle string_or_null_h, const jchar* name, int len, TRAPS) {
  // shared table always uses java_lang_String::hash_code
  //根据字符串和长度获取哈希值，这个哈希值将用于在常量池中查找字符串
  unsigned int hash = java_lang_String::hash_code(name, len);
  //根据哈希值查找字符串
  oop found_string = lookup_shared(name, len, hash);
  //找到了就直接返回
  if (found_string != nullptr) {
    return found_string;
  }
  //没找到但是开启了替代哈希算法，就使用替代哈希算法重新计算哈希值。
  if (_alt_hash) {
    hash = hash_string(name, len, true);
  }
  found_string = do_lookup(name, len, hash);
  //一样的逻辑找到就返回
  if (found_string != nullptr) {
    return found_string;
  }
  //没有找到，说明要插入到常量池中
  return do_intern(string_or_null_h, name, len, hash, THREAD);
}
```

这个方法的任务主要就是完成八股文中的首先去常量池中寻找的逻辑

```c++
oop StringTable::do_intern(Handle string_or_null_h, const jchar *name,
                           int len, uintx hash, TRAPS) {
    //句柄标记，用于清理在这个作用域中创建的所有句柄。
    HandleMark hm(THREAD);  // cleanup strings created
    //字符串句柄
    Handle string_h;
    //如果参数的句柄不为空就使用参数的，如果为空就创建一个句柄
    if (!string_or_null_h.is_null()) {
        string_h = string_or_null_h;
    } else {
        string_h = java_lang_String::create_from_unicode(name, len, CHECK_NULL);
    }

...

    // Notify deduplication support that the string is being interned.  A string
    // must never be deduplicated after it has been interned.  Doing so interferes
    // with compiler optimizations done on e.g. interned string literals.
    //如果启用了字符串去重（deduplication），就通知字符串去重系统这个字符串正在被内部化
    if (StringDedup::is_enabled()) {
        StringDedup::notify_intern(string_h());
    }
    //:创建一个查找对象，用于在常量池中查找字符串
    StringTableLookupOop lookup(THREAD, hash, string_h);
    // 创建一个获取对象，用于从常量池中获取字符串。
    StringTableGet stg(THREAD);

    bool rehash_warning;
    //执行添加操作
    do {
        // Callers have already looked up the String using the jchar* name, so just go to add.
        //把字符串句柄包装成一个弱引用句柄，弱引用就是没有弱引用了就会被回收
        WeakHandle wh(_oop_storage, string_h);
        // The hash table takes ownership of the WeakHandle, even if it's not inserted.
        //插入到常量池中
        if (_local_table->insert(THREAD, lookup, wh, &rehash_warning)) {
            update_needs_rehash(rehash_warning);
            return wh.resolve();
        }
        // 假如另一个线程并发执行了添加操作，那么返回值就会存在于表中。
        // 如果字符串在并发情况下被垃圾回收，那么可能会失败，所以要循环尝试直到成功为止。
        if (_local_table->get(THREAD, lookup, stg, &rehash_warning)) {
            update_needs_rehash(rehash_warning);
            return stg.get_res_oop();
        }
    } while (true);
}
```

（这里简单说下什么是字符串去重，简单来说是jvm那帮人认为项目中的字符串大多数都是重复的，可以通过字符串去重来减少重复字符串从而减少堆内存使用量毕竟不是所有人都会用intern的，用参数UseStringDeduplication来开启，默认是关闭的，因为开启的话我们的GC就会去扫描重复字符串然后去重，这当然会加大CPU的压力，所以默认是关闭的）

这个方法信息量就很大了

首先这里因为我们的`string_or_null_h`是在上面`intern`方法中定义的：`Handle string;`所以这里肯定是为空的，所以就要去创建一个句柄，这里简单介绍一下jvm中的句柄：

>在 JVM 中，句柄（Handle）是一个用于引用 Java 对象的指针或引用,在 HotSpot JVM 中，`Handle` 是一个 C++ 类，它提供了一种安全的引用 Java 对象的方式。`Handle` 会在栈上创建，当栈帧被弹出时，与之关联的 `Handle` 也会自动销毁。这样可以保证不会出现悬挂引用（dangling reference），即引用已经被销毁的对象。
>
>例如，`Handle string_h;` 创建了一个句柄，这个句柄可以用来安全地引用一个 Java 字符串。

简单可以理解为是引用指向一个Java对象，好，记住这里这个Java对象，然后我们接着往下看，抛开不重要的部分

我们接下来会把创建好的句柄转换为一个弱引用句柄

>在 JVM 中，`WeakHandle` 是一种特殊类型的句柄，用于引用 Java 对象，但不会阻止该对象被垃圾收集器回收。
>
>在 Java 中，弱引用（Weak Reference）是一种特殊的引用，它不会阻止其引用的对象被垃圾收集器回收。当垃圾收集器工作时，无论内存是否足够，都会回收被弱引用关联的对象。在 JVM 的实现中，`WeakHandle` 就是这样一种弱引用的实现。

简单来说就是一个可以被回收的句柄，我们可以认为表示了这个对象可以被回收

最后就是插入到常量池中的操作了(无限循环和查找都是为了解决多线程和GC这两种场景，这里不过多赘述，大家可以自己思考一下)：

```c++
_local_table->insert(THREAD, lookup, wh, &rehash_warning)
```

这里和笔者上文的猜测一样，`_local_table`就是我们的字符串 常量池！，他的定义：

```c++
 _local_table = new StringTableHash(start_size_log_2, END_SIZE, REHASH_LEN, true);
```

也就是一个分配在本地内存中的一个`StringTableHash`，那么又为什么说在堆上呢？

我们在看，真正放入常量池的是什么？对，是弱引用句柄，那这个句柄指向的对象是什么呢？

```c++
 string_h = java_lang_String::create_from_unicode(name, len, CHECK_NULL);
```

我们去看一下`create_from_unicode`方法：

```c++
Handle java_lang_String::create_from_unicode(const jchar* unicode, int length, TRAPS) {
    //判断是不是 Latin-1 编码
  bool is_latin1 = CompactStrings && UNICODE::is_latin1(unicode, length);
  //根据字符串长度来新建句柄
  Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
  //取新创建的 String 对象的值，这个值是一个字节数组。
  typeArrayOop buffer = value(h_obj());
  assert(TypeArrayKlass::cast(buffer->klass())->element_type() == T_BYTE, "only byte[]");
  //将 Unicode 字符串的字符复制到字节数组中。如果字符串是 Latin-1 编码，每个 Unicode 字符将被转换为一个字节并存储。否则，每个 Unicode 字符将被存储为一个字符
  if (is_latin1) {
    for (int index = 0; index < length; index++) {
      buffer->byte_at_put(index, (jbyte)unicode[index]);
    }
  } else {
    for (int index = 0; index < length; index++) {
      buffer->char_at_put(index, unicode[index]);
    }
  }
//将 Unicode 字符串转换为 UTF-8 编码，然后将新创建的 String 对象也转换为 UTF-8 编码，比较两个字符串是否相同。如果不同，抛出异常。
#ifdef ASSERT
  ...
#endif
//返回句柄
  return h_obj;
}
```

我们可以看到，这里会先创建好句柄，然后再把我们的字符串的内容put进入到我们的句柄对象的字节数组中

那么我们继续看如何创建句柄的：

```c++
Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
 ...
  //创建了一个新的 String 对象。oop 是 "ordinary object pointer" 的缩写，是 JVM 内部用于表示 Java 对象的类型。allocate_instance 方法在堆上为新对象分配内存。
  oop obj;
  obj = vmClasses::String_klass()->allocate_instance(CHECK_NH);

  // Create the char array.  The String object must be handlized here
  // because GC can happen as a result of the allocation attempt.
  //创建一个句柄，用于安全地引用新创建的 String 对象。这是因为接下来的代码可能会触发垃圾收集，可能会移动对象的内存位置。
  Handle h_obj(THREAD, obj);
  //创建了一个新的字节数组，用于存储 String 对象的字符。如果字符串是 Latin-1 编码，每个字符占用 1 字节；如果是 UTF-16 编码，每个字符占用 2 字节。
  int arr_length = is_latin1 ? length : length << 1; // 2 bytes per UTF16.
  typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;

  // Point the String at the char array
  //将新创建的字节数组设置为 String 对象的值。
  obj = h_obj();
  set_value(obj, buffer);
  ...
  //返回句柄
  return h_obj;
}
```

这里就做了两件事：

- ` obj = vmClasses::String_klass()->allocate_instance(CHECK_NH);`来创建一个字符串对象

- 给这个字符串对象分配一个字节数组用来存放字符串内容

我们顺便看下如何创建字符串对象的：

```c++
instanceOop InstanceKlass::allocate_instance(TRAPS) {
  bool has_finalizer_flag = has_finalizer(); // Query before possible GC
  size_t size = size_helper();  // Query before forming handle.

  instanceOop i;

  i = (instanceOop)Universe::heap()->obj_allocate(this, size, CHECK_NULL);
  if (has_finalizer_flag && !RegisterFinalizersAtInit) {
    i = register_finalizer(i, CHECK_NULL);
  }
  return i;
}
```

有没有一种很亲切的感觉？笔者之前写过G1和SGC的新对象分配代码，这段代码熟的不能再熟了，就是在堆上分配一个新对象，然后把这个字符串对象赋值并且把句柄返回出去

所以以上代码总结就是根据字符串的长度在堆上创建一个字符串对象，然后把字符串内容通过字节数组的方式写入到对象中，然后把这个对象以弱引用句柄的方式放到我们的字符串常量池中！



## 总结

至少在我们默认的openjdk+hotspot中，单纯的说字符串常量池在堆中是不完全正确的，正确且严谨的说法应该是：

**字符串常量池在hotspot中的实现来说：常量池本身是一个分配在本地内存的`ConcurrentHashTable`数据结构类似于`HashMap`，常量池里面存放的是字符串对象的弱引用句柄而不是字符串对象本身**

另外intern的返回值严格来说应该是：

**该字符串在字符串常量池中的一个引用并且是只在当前线程内有效的本地引用，值就是当前字符串**